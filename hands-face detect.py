# -*- coding: utf-8 -*-
"""cvlab2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZcOpftGTnwA0S6hPqJb6a17f4jUENU_U
"""

#Μέρος 1: Παρακολούθηση Προσώπου και Χεριών 
#με Χρήσητου Πεδίου Οπτικής Ροής με τη μέθοδοLucas-Kanade

# Commented out IPython magic to ensure Python compatibility.
#Βιβλιοθηκες

import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt
import cv2
from scipy import ndimage as sci
import statistics
from scipy import stats as sciSt
import numpy
import cv20_lab2_2_utils as p1
import math
import scipy
from scipy import signal
import cv20_lab1_part2_utils as p2
#from google.colab.patches import cv2_imshow

# 1.2.1 Υλοποίηση του Αλγόριθμου των Lucas-Kanade

#set rng the range of loops until d converges
rng = 10

def Lucas_Kanade(img1, img2, gauss_size, epsilon, dx0 ,dy0):
  (dxi,dyi) = (dx0,dy0)

  #Gaussian 
  gauss1d = cv2.getGaussianKernel(int(np.ceil(3*gauss_size)*2+1),gauss_size)
  gauss = gauss1d @ gauss1d.T
  #calc of shifted img1 and its derivatives
  I = np.gradient(img1)
  Ix = I[1]
  Iy = I[0]
  for i in range(rng):
    #calc of xo and yo
    x0,y0  =  numpy.meshgrid(range(img1.shape[1]),range(img1.shape[0]))
    #In-1(x+d)
    img1_shft = sci.map_coordinates(img1,[numpy.ravel(y0+dyi),  numpy.ravel(x0+dxi)],order=1)
    #dIx(x+d)
    A1 = sci.map_coordinates(Ix,[numpy.ravel(y0+dyi),  numpy.ravel(x0+dxi)],order=1)
    #dIy(x+d)
    A2 = sci.map_coordinates(Iy,[numpy.ravel(y0+dyi),  numpy.ravel(x0+dxi)],order=1)
    #set of A(x) and E(x)
    A1 = np.reshape(A1,(-1,len(img2[0])))
    A2 = np.reshape(A2,(-1,len(img2[0])))
    A = np.array([A1, A2])
    img1_shft = np.reshape(img1_shft,(-1,len(img2[0])))
    E = img2 - img1_shft

    #set the tables for the calculation of u
    T1a = cv2.filter2D(np.square(A1), -1, gauss) + epsilon
    T1bc = cv2.filter2D(np.multiply(A1,A2), -1, gauss)
    T1d = cv2.filter2D(np.square(A2), -1, gauss) + epsilon
    T1 = [[T1a,T1bc],[T1bc, T1d]]
    
    T2a = cv2.filter2D(np.multiply(A1,E), -1, gauss)
    T2b = cv2.filter2D(np.multiply(A2,E), -1, gauss)
    T2 = [T2a, T2b]
    tmp =  np.multiply(T1a,T1d) - np.multiply(T1bc,T1bc)
    ux = np.divide((np.multiply(T1d,T2a) - np.multiply(T1bc,T2b)),tmp)
    uy = np.divide((np.multiply(T1a,T2b) - np.multiply(T1bc,T2a)),tmp)
    #print(ux,uy)
    (dxi,dyi) = (dxi + ux, dyi + uy)
  return dxi, dyi

#1.2.2 Υπολογισμός της Μετατόπισης του Προσώπου και των Χεριών από το ΠεδίοΟπτικής Ροής

#υλοποιηση της displ
def displ(dx, dy):
  d_nrg = np.sqrt(np.square(dx) + np.square(dy))
  max = 0 
  #set low boundry - median???
  size = len(d_nrg)* len(d_nrg[0])
  bound = np.sum(d_nrg) / size
  counter = 0
  
  for i in range(len(dx)):
    for k in range(len(dx[0])):
      temp = np.sqrt(np.square(dx[i][k]) + np.square(dy[i][k]))
      if temp <= bound:
        dx[i][k] = 0
        dy[i][k] = 0
        counter +=1
  counterx = size - counter
  countery = size - counter
  fx = 0
  fy = 0
  if counterx != 0:
    fx = np.sum(dx)/counterx
  if countery != 0:
    fy = np.sum(dy)/countery  
  return int(round(fx)), int(round(fy))



#εισαγωγη των εικόνων σε μορφη βιντεο
#Δημιουργια πινακα με indexes χρονος-x-y-rgb/gray [t][x][y][...]
#Bounding box Πρόσωπο:[138,88,73,123], Αριστερό χέρι:[47,243,71,66], Δεξί χέρι:[162,264,83,48]
video = []
face = []
left = []
right = []
for i in range(66):
  name = 'GreekSignLanguage/'+str(i+1)+'.png'
  img = cv2.imread(name, cv2.IMREAD_COLOR)
  img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
  img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  img = img.astype(np.float)/255
  
  video.append(img)

u = [ [138,88] , [47,243] , [162,264] ]
face.append(video[0][u[0][0]:u[0][0]+123,u[0][1]:u[0][1]+73])
left.append(video[0][u[1][0]:u[1][0]+66,u[1][1]:u[1][1]+71])
right.append(video[0][u[2][0]:u[2][0]+48,u[2][1]:u[2][1]+83])

df = np.zeros((123,73))
dl = np.zeros((66,71))
dr = np.zeros((48,83))

headpath = "lk/head/"
leftpath = "lk/left/"
rightpath = "lk/right/"

for i in range(66):
  print(i)
  face_t = video[i+1][u[0][0]:u[0][0]+123,u[0][1]:u[0][1]+73]
  left_t = video[i+1][u[1][0]:u[1][0]+66,u[1][1]:u[1][1]+71]
  right_t = video[i+1][u[2][0]:u[2][0]+48,u[2][1]:u[2][1]+83]
  #cv2.imshow('face',face[i])
  cv2.imwrite('/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/gray.png',face[i])
  dx_f,dy_f = Lucas_Kanade(face[i],face_t,3,0.08,df,df)
  dx_l,dy_l = Lucas_Kanade(left[i],left_t,2,0.05,dl,dl)
  dx_r,dy_r = Lucas_Kanade(right[i],right_t,2,0.05,dr,dr)

  dx_f1=cv2.resize(dx_f, None, fx=0.5, fy=0.5)
  dy_f1=cv2.resize(dy_f, None, fx=0.5, fy=0.5)
  fig= plt.figure()
  axs= fig.add_subplot()
  axs.quiver(-dx_f1,-dy_f1,angles= 'xy')
  axs.set_title("Face Optical Flow")
  plt.gca().invert_yaxis()
  plt.gca().set_aspect('equal')
  plt.savefig(headpath + str(i), bbox_inches='tight')
    
  dx_l1=cv2.resize(dx_l, None, fx=0.5, fy=0.5)
  dy_l1=cv2.resize(dy_l, None, fx=0.5, fy=0.5)
  fig= plt.figure()
  axs= fig.add_subplot()
  axs.quiver(-dx_l1,-dy_l1,angles= 'xy')
  axs.set_title("Left Hand Optical Flow")
  plt.gca().invert_yaxis()
  plt.gca().set_aspect('equal')
  plt.savefig(leftpath + str(i), bbox_inches='tight')


  dx_r1=cv2.resize(dx_r, None, fx=0.5, fy=0.5)
  dy_r1=cv2.resize(dy_r, None, fx=0.5, fy=0.5)
  fig= plt.figure()
  axs= fig.add_subplot()
  axs.quiver(-dx_r1,-dy_r1,angles= 'xy')
  axs.set_title("Right Hand Optical Flow")
  plt.gca().invert_yaxis()
  plt.gca().set_aspect('equal')
  plt.savefig(rightpath + str(i), bbox_inches='tight')
  

  dx_f,dy_f = displ(dx_f,dy_f)
  dx_l,dy_l = displ(dx_l,dy_l)
  dx_r,dy_r = displ(dx_r,dy_r)

  print(dx_f,dy_f)
  print(dx_l,dy_l)
  print(dx_r,dy_r)

  u = [ [u[0][0]+dx_f,u[0][1]+dy_f] , [u[1][0]+dx_l,u[1][1]+dy_l] , [u[2][0]+dx_r,u[2][1]+dy_r] ]
  face.append(video[i+1][u[0][0]:u[0][0]+123,u[0][1]:u[0][1]+73])
  left.append(video[i+1][u[1][0]:u[1][0]+66,u[1][1]:u[1][1]+71])
  right.append(video[i+1][u[2][0]:u[2][0]+48,u[2][1]:u[2][1]+83])

#1.2.3 Πολυ-Κλιμακωτός Υπολογισμός Οπτικής Ροής
def polyclimaticLucas_Kanade(img1, img2, gauss_size, epsilon, dx0 ,dy0, number):
    #generate a gaussian pyramid for both img1 and img2
    #copy img1 to I1
    I1 = img1.copy()
    #copy img2 to I2
    I2 = img2.copy()
    #list of scaled images of img1 
    gp1 = [I1]
    #list of scaled images of img1
    gp2 = [I2]
    #standard deviation = 3,(value can be changed)
    sigma = 3
    for i in range(number):
        #pass it form low pass filter with sigma = 3
        #I1:low pass filter
        I1 = sci.gaussian_filter(I1,sigma)
        #1 scale down
        I1 = cv2.pyrDown(I1)
        #save it in a list
        gp1.append(I1)
        #I2:low pass filter
        I2 = sci.gaussian_filter(I2,sigma)
        #1 scale down
        I2 = cv2.pyrDown(I2)
        #save it in a list
        gp2.append(I2)
    #reverse gp1 and gp2 so to iterate from small to big scales
    gp1.reverse()
    gp2.reverse()
    (dx,dy) = (dx0,dy0)
    for (i,j) in zip(gp1,gp2):
        dx0 = cv2.resize(dx,(len(i[0]),len((i))))
        dy0 = cv2.resize(dy,(len(i[0]),len(i)))
        (dx,dy) = Lucas_Kanade(i, j, gauss_size, epsilon, dx0 ,dy0)
    return dx,dy

#εισαγωγη των εικόνων σε μορφη βιντεο
#Δημιουργια πινακα με indexes χρονος-x-y-rgb/gray [t][x][y][...]
#Bounding box Πρόσωπο:[138,88,73,123], Αριστερό χέρι:[47,243,71,66], Δεξί χέρι:[162,264,83,48]
video = []
face = []
left = []
right = []
for i in range(66):
  name = 'GreekSignLanguage/'+str(i+1)+'.png'
  img = cv2.imread(name, cv2.IMREAD_COLOR)
  img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
  img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  img = img.astype(np.float)/255
  
  video.append(img)

u = [ [138,88] , [47,243] , [162,264] ]
face.append(video[0][u[0][0]:u[0][0]+123,u[0][1]:u[0][1]+73])
left.append(video[0][u[1][0]:u[1][0]+66,u[1][1]:u[1][1]+71])
right.append(video[0][u[2][0]:u[2][0]+48,u[2][1]:u[2][1]+83])


df = np.zeros((123,73))
dl = np.zeros((66,71))
dr = np.zeros((48,83))

headpath = "plk/head/"
leftpath = "plk/left/"
rightpath = "plk/right/"

for i in range(65):
  print(i)
  face_t = video[i+1][u[0][0]:u[0][0]+123,u[0][1]:u[0][1]+73]
  left_t = video[i+1][u[1][0]:u[1][0]+66,u[1][1]:u[1][1]+71]
  right_t = video[i+1][u[2][0]:u[2][0]+48,u[2][1]:u[2][1]+83]
  
  dx_f,dy_f = polyclimaticLucas_Kanade(face[i],face_t,3,0.08,0,0,3)
  dx_l,dy_l = polyclimaticLucas_Kanade(left[i],left_t,2,0.05,dl,dl,3)
  dx_r,dy_r = polyclimaticLucas_Kanade(right[i],right_t,2,0.05,dr,dr,3)

  
  dx_f1=cv2.resize(dx_f, None, fx=0.5, fy=0.5)
  dy_f1=cv2.resize(dy_f, None, fx=0.5, fy=0.5)
  fig= plt.figure()
  axs= fig.add_subplot()
  axs.quiver(-dx_f1,-dy_f1,angles= 'xy')
  axs.set_title("Face Optical Flow")
  plt.gca().invert_yaxis()
  plt.gca().set_aspect('equal')
  plt.savefig(headpath + str(i), bbox_inches='tight')
    
  dx_l1=cv2.resize(dx_l, None, fx=0.5, fy=0.5)
  dy_l1=cv2.resize(dy_l, None, fx=0.5, fy=0.5)
  fig= plt.figure()
  axs= fig.add_subplot()
  axs.quiver(-dx_l1,-dy_l1,angles= 'xy')
  axs.set_title("Left Hand Optical Flow")
  plt.gca().invert_yaxis()
  plt.gca().set_aspect('equal')
  plt.savefig(leftpath + str(i), bbox_inches='tight')


  dx_r1=cv2.resize(dx_r, None, fx=0.5, fy=0.5)
  dy_r1=cv2.resize(dy_r, None, fx=0.5, fy=0.5)
  fig= plt.figure()
  axs= fig.add_subplot()
  axs.quiver(-dx_r1,-dy_r1,angles= 'xy')
  axs.set_title("Right Hand Optical Flow")
  plt.gca().invert_yaxis()
  plt.gca().set_aspect('equal')
  plt.savefig(rightpath + str(i), bbox_inches='tight')
  

  dx_f,dy_f = displ(dx_f,dy_f)
  dx_l,dy_l = displ(dx_l,dy_l)
  dx_r,dy_r = displ(dx_r,dy_r)
    
  print(dx_f,dy_f)
  print(dx_l,dy_l)
  print(dx_r,dy_r)

  u = [ [u[0][0]+dx_f,u[0][1]+dy_f] , [u[1][0]+dx_l,u[1][1]+dy_l] , [u[2][0]+dx_r,u[2][1]+dy_r] ]
  face.append(video[i+1][u[0][0]:u[0][0]+123,u[0][1]:u[0][1]+73])
  left.append(video[i+1][u[1][0]:u[1][0]+66,u[1][1]:u[1][1]+71])
  right.append(video[i+1][u[2][0]:u[2][0]+48,u[2][1]:u[2][1]+83])

#possible values
sigma = 4
s = 2
t = 1.5
k = 0.005

#2.1.1 Harris Detector
def HarrisDetector(img):
    sigma = 4
    s = 2
    t = 1.5
    k = 0.005
    img = img/256
    #gaussian 2d n 1d
    g_xy = cv2.getGaussianKernel(int(np.ceil(3*s)*2+1),s)
    g_xy_2 = g_xy @ g_xy.T
    g_t = cv2.getGaussianKernel(int(np.ceil(3*t)*2+1),t)
    
    #create L 
    I_filtered = cv2.filter2D(img.T[:],-1,g_xy_2)
    If = sci.convolve1d(I_filtered.T[:][:],g_t[:,0])

    #L gradient
    W = [-1.,0.,1.]
    L = []
    
    L.append(sci.convolve1d(img,W,2))
    L.append(sci.convolve1d(img,W,1))
    L.append(sci.convolve1d(img,W,0))
    L = np.array([[np.multiply(L[2],L[2]),np.multiply(L[2],L[1]),np.multiply(L[2],L[0])],[np.multiply(L[1],L[2]),np.multiply(L[1],L[1]),np.multiply(L[1],L[0])],[np.multiply(L[0],L[2]),np.multiply(L[0],L[1]),np.multiply(L[0],L[0])]])
    M = []
    g_xy = cv2.getGaussianKernel(int(np.ceil(3*s*sigma)*2+1),s*sigma)
    g_xy_2 = g_xy @ g_xy.T
    g_t = cv2.getGaussianKernel(int(np.ceil(3*sigma*t)*2+1),t*sigma)
    for i in range(3):
        for k in range(3):
            I_filtered = cv2.filter2D(L[i][k].T[:],-1,g_xy_2)
            If = sci.convolve1d(I_filtered.T[:][:],g_t[:,0])
            M.append(If)
    
    dtr = M[0] * (M[4]*M[8] - M[5]*M[7]) - M[1]*(M[3]*M[8]-M[6]*M[5]) + M[2]*(M[3]*M[8]-M[4]*M[6])
    #H = dtr - k*(M[0]+M[4]+M[8])**3 doesn't work
    H = dtr + k*(M[0]+M[4]+M[8])**3
    return H

#possible values
sigma = 4
s = 2
t = 1.5
k = 0.005
def GaborDetector(img):
    sigma = 4
    s = 2
    t = 1.5
    k = 0.005
    gaussian1d = cv2.getGaussianKernel(int(np.ceil(3*sigma)*2+1),sigma)
    gaussian = gaussian1d @ gaussian1d.T
    Is = cv2.filter2D(img,-1,gaussian)
    w = 4/t
    #pedio
    heu = []
    hod = []
    pedio = np.arange(-2*t,2*t+1)
    heu = (np.cos(2*np.pi*pedio*w)*np.exp(-pedio**2/(2*t**2)))
    hod = (np.sin(2*np.pi*pedio*w)*np.exp(-pedio**2/(2*t**2)))
    #L1 norm
    L1_heu = np.linalg.norm(heu,ord = 1)
    L1_hod = np.linalg.norm(hod,ord = 1)
    
    H = (sci.convolve1d(Is,heu,2))**2 + (sci.convolve1d(Is,hod,2))**2
    n = int(np.ceil(3*sigma)*2 + 1)
    B_sq = p2.disk_strel(n)
    Cond1 = (H == cv2.dilate(H,B_sq))
    Hmax = np.amax(H)
    Cond2 = (H>0.3*Hmax)
    H = H*Cond1*Cond2
    #H = cv2.filter2D(Is,-1,L1_heu)**2 + cv2.filter2D(Is,-1,L1_hod)**2
    return H

#read all videos
boxing = []
running = []
walking = []
from os import listdir
from os.path import isfile, join
boxingfiles = [f for f in listdir('boxing/') if isfile(join('boxing', f))]
runningfiles = [f for f in listdir('running/') if isfile(join('running', f))]
walkingfiles = [f for f in listdir('walking/') if isfile(join('walking', f))]
for i,j,z in zip(boxingfiles,runningfiles,walkingfiles):
    box = 'boxing/' + i
    box = p1.read_video(box,200,0)
    boxing.append(box)
    
    run = 'running/' + j
    run = p1.read_video(run,200,0)
    running.append(run)
    
    walk = 'walking/' + z
    walk = p1.read_video(walk,200,0)
    walking.append(walk)

#Harris filtering
print('Starting gabor filtering')
print('Boxing')
path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/Harris"
#create boxing folder
pathBoxing = path + "/boxingResults/Boxing"
counter = 1
for b in boxing:
    print('Num. of video',counter)
    q1 = HarrisDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    p1.show_detection(b,teliko,save_path=pathBoxing + str(counter))
    print("end")
    counter +=1

#create walking folder
pathWalking = path + "/walkingResults/Walking"
counter = 1
for w in walking:
    print('Num. of video',counter)
    q1 = HarrisDetector(w)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)    
    p1.show_detection(w,teliko,save_path=pathWalking + str(counter))
    print("end")
    counter+=1
    
#create running folder
pathRunning = path + "/runningResults/Running"
counter = 1
for r in running:
    print('Num. of video',counter)
    
    q1 = HarrisDetector(r)
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)    
    p1.show_detection(r,teliko,save_path=pathRunning + str(counter))
    print("end")
    counter +=1

import os
#Gabor filtering
print('Starting gabor filtering')
print('Boxing')
path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2"
#create boxing folder
pathBoxing = path + "/boxingResults/Boxing"
counter = 1
for b in boxing:
    print('Num. of video',counter)
    q1 = GaborDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    p1.show_detection(b,teliko,save_path=pathBoxing + str(counter))
    print("end")
    counter +=1

#create walking folder
pathWalking = path + "/walkingResults/Walking"
counter = 1
for w in walking:
    print('Num. of video',counter)
    q1 = GaborDetector(w)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)    
    p1.show_detection(w,teliko,save_path=pathWalking + str(counter))
    print("end")
    counter+=1
    
#create running folder
pathRunning = path + "/runningResults/Running"
counter = 1
for r in running:
    print('Num. of video',counter)
    q1 = GaborDetector(r)
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)    
    p1.show_detection(r,teliko,save_path=pathRunning + str(counter))
    print("end")
    counter +=1

#create videos from frames for Gabor
print('Creating Videos')
print('Creating Boxing Videos...')
boxing_path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/boxingResults/Boxing"
fps = 15
for i in range(16):
    print("Reading",i+1,  "video")
    path = boxing_path + str(i+1)
    frame_array = []
    for j in range(200):
        frame_name = path + "/frame" + str(j) + '.png'
        img = cv2.imread(frame_name)
        height, width, layers = img.shape
        size = (width,height)
    
        #inserting the frames into an image array
        frame_array.append(img)
    pathOut = path +"/BoxingVideo.avi"
    out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size)
    print("Processing...")
    for i in range(len(frame_array)):
        # writing to a image array
        out.write(frame_array[i])
    out.release()
    print("Ending Processing...")
    
print('Creating Walking Videos...')
walking_path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/walkingResults/Walking"
fps = 15
for i in range(16):
    print("Reading",i+1, "video")
    path = walking_path + str(i+1)
    frame_array = []
    for j in range(200):
        frame_name = path + "/frame" + str(j) + '.png'
        img = cv2.imread(frame_name)
        height, width, layers = img.shape
        size = (width,height)
    
        #inserting the frames into an image array
        frame_array.append(img)
    pathOut = path +"/WalkingVideo.avi"
    out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size)
    print("Processing...")
    for i in range(len(frame_array)):
        # writing to a image array
        out.write(frame_array[i])
    out.release()
    print("Ending Processing...")
 
print('Creating Running Videos...')
running_path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/runningResults/Running"
fps = 15
for i in range(16):
    print("Reading",i+1,  "video")
    path = running_path + str(i+1)
    frame_array = []
    for j in range(200):
        frame_name = path + "/frame" + str(j) + '.png'
        img = cv2.imread(frame_name)
        height, width, layers = img.shape
        size = (width,height)
    
        #inserting the frames into an image array
        frame_array.append(img)
    pathOut = path +"/RunningVideo.avi"
    out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size)
    print("Processing...")
    for i in range(len(frame_array)):
        # writing to a image array
        out.write(frame_array[i])
    out.release()
    print("Ending Processing...")

#create videos from frames for Gabor
print('Creating Videos')
print('Creating Boxing Videos...')
boxing_path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/Harris/boxingResults/Boxing"
fps = 15
for i in range(16):
    print("Reading",i+1,  "video")
    path = boxing_path + str(i+1)
    frame_array = []
    for j in range(200):
        frame_name = path + "/frame" + str(j) + '.png'
        img = cv2.imread(frame_name)
        height, width, layers = img.shape
        size = (width,height)
    
        #inserting the frames into an image array
        frame_array.append(img)
    pathOut = path +"/BoxingVideo.avi"
    out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size)
    print("Processing...")
    for i in range(len(frame_array)):
        # writing to a image array
        out.write(frame_array[i])
    out.release()
    print("Ending Processing...")
    
print('Creating Walking Videos...')
walking_path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/Harris/walkingResults/Walking"
fps = 15
for i in range(16):
    print("Reading",i+1, "video")
    path = walking_path + str(i+1)
    frame_array = []
    for j in range(200):
        frame_name = path + "/frame" + str(j) + '.png'
        img = cv2.imread(frame_name)
        height, width, layers = img.shape
        size = (width,height)
    
        #inserting the frames into an image array
        frame_array.append(img)
    pathOut = path +"/WalkingVideo.avi"
    out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size)
    print("Processing...")
    for i in range(len(frame_array)):
        # writing to a image array
        out.write(frame_array[i])
    out.release()
    print("Ending Processing...")
 
print('Creating Running Videos...')
running_path = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/Harris/runningResults/Running"
fps = 15
for i in range(16):
    print("Reading",i+1,  "video")
    path = running_path + str(i+1)
    frame_array = []
    for j in range(200):
        frame_name = path + "/frame" + str(j) + '.png'
        img = cv2.imread(frame_name)
        height, width, layers = img.shape
        size = (width,height)
    
        #inserting the frames into an image array
        frame_array.append(img)
    pathOut = path +"/RunningVideo.avi"
    out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size)
    print("Processing...")
    for i in range(len(frame_array)):
        # writing to a image array
        out.write(frame_array[i])
    out.release()
    print("Ending Processing...")

#lucas kanade returning gradient
def Lucas_Kanade_new(img1, img2, gauss_size, epsilon, dx0 ,dy0):
  (dxi,dyi) = (dx0,dy0)

  #Gaussian 
  gauss1d = cv2.getGaussianKernel(int(np.ceil(3*gauss_size)*2+1),gauss_size)
  gauss = gauss1d @ gauss1d.T
  #calc of shifted img1 and its derivatives
  I = np.gradient(img1)
  Ix = I[1]
  Iy = I[0]
  for i in range(rng):
    #calc of xo and yo
    x0,y0  =  numpy.meshgrid(range(img1.shape[1]),range(img1.shape[0]))
    #In-1(x+d)
    img1_shft = sci.map_coordinates(img1,[numpy.ravel(y0+dyi),  numpy.ravel(x0+dxi)],order=1)
    #dIx(x+d)
    A1 = sci.map_coordinates(Ix,[numpy.ravel(y0+dyi),  numpy.ravel(x0+dxi)],order=1)
    #dIy(x+d)
    A2 = sci.map_coordinates(Iy,[numpy.ravel(y0+dyi),  numpy.ravel(x0+dxi)],order=1)
    #set of A(x) and E(x)
    A1 = np.reshape(A1,(-1,len(img2[0])))
    A2 = np.reshape(A2,(-1,len(img2[0])))
    A = np.array([A1, A2])
    img1_shft = np.reshape(img1_shft,(-1,len(img2[0])))
    E = img2 - img1_shft

    #set the tables for the calculation of u
    T1a = cv2.filter2D(np.square(A1), -1, gauss) + epsilon
    T1bc = cv2.filter2D(np.multiply(A1,A2), -1, gauss)
    T1d = cv2.filter2D(np.square(A2), -1, gauss) + epsilon
    T1 = [[T1a,T1bc],[T1bc, T1d]]
    
    T2a = cv2.filter2D(np.multiply(A1,E), -1, gauss)
    T2b = cv2.filter2D(np.multiply(A2,E), -1, gauss)
    T2 = [T2a, T2b]
    tmp =  np.multiply(T1a,T1d) - np.multiply(T1bc,T1bc)
    ux = np.divide((np.multiply(T1d,T2a) - np.multiply(T1bc,T2b)),tmp)
    uy = np.divide((np.multiply(T1a,T2b) - np.multiply(T1bc,T2a)),tmp)
    #print(ux,uy)
    (dxi,dyi) = (dxi + ux, dyi + uy)
  return dxi, dyi,I

#polyclimatic lucas kanade returning gradient
def polyclimaticLucas_Kanade_new(img1, img2, gauss_size, epsilon, dx0 ,dy0, number):
    #generate a gaussian pyramid for both img1 and img2
    #copy img1 to I1
    I1 = img1.copy()
    #copy img2 to I2
    I2 = img2.copy()
    #list of scaled images of img1 
    gp1 = [I1]
    #list of scaled images of img1
    gp2 = [I2]
    #standard deviation = 3,(value can be changed)
    sigma = 3
    for i in range(number):
        #pass it form low pass filter with sigma = 3
        #I1:low pass filter
        I1 = sci.gaussian_filter(I1,sigma)
        #1 scale down
        I1 = cv2.pyrDown(I1)
        #save it in a list
        gp1.append(I1)
        #I2:low pass filter
        I2 = sci.gaussian_filter(I2,sigma)
        #1 scale down
        I2 = cv2.pyrDown(I2)
        #save it in a list
        gp2.append(I2)
    #reverse gp1 and gp2 so to iterate from small to big scales
    gp1.reverse()
    gp2.reverse()
    (dx,dy) = (dx0,dy0)
    for (i,j) in zip(gp1,gp2):
        dx0 = cv2.resize(dx,(len(i[0]),len((i))))
        dy0 = cv2.resize(dy,(len(i[0]),len(i)))
        (dx,dy,grad) = Lucas_Kanade_new(i, j, gauss_size, epsilon, dx0 ,dy0)
    return dx,dy,grad

#2.2 Χωρο-χρονικοί Ιστογραφικοί Περιγραφητές
#code for testing on 1 video
test = p1.read_video('walking/person04_walking_d1_uncomp.avi',200,0)
test = test.astype(np.float)/255

dh = np.zeros((120,160)) # καθε frame ειναι 120Χ160

x=120
y=160
z=0
temp=np.zeros((x,y))
temp_next=np.zeros((x,y))

#print(temp,temp.shape)        

for z in range (1): 
    for i in range (x):
        for j in range (y):
            temp[i][j]=test[i][j][z]
            temp_next[i][j]=test[i][j][z+1]
    
    
    #d=lk(temp,temp_next,3,0.08,dh,dh)             # lk or 
    d=polyclimaticLucas_Kanade_new(temp,temp_next,3,0.08,dh,dh,3)       # multi-lk 
    #
    dx_l1=cv2.resize(d[0], None, fx=0.5, fy=0.5)
    dy_l1=cv2.resize(d[1], None, fx=0.5, fy=0.5)
    fig, ax = plt.subplots()
    Q = ax.quiver(-dx_l1,-dy_l1,angles='xy')
    #
    plt.gca().set_aspect('equal')
    plt.gca().invert_yaxis()
    #plt.savefig('part2.2.1multi/{}part2_{}.png'.format(filename, z+1))  
    plt.show('g')
    
    # gia na epistrefei gradient
    grad=d[2]
    print("gradient ",z, "=",grad)
    print(np.array(grad).shape)
    plt.figure()
    plt.imshow(grad[0][:][:])
    plt.figure()
    plt.imshow(grad[1][:][:])
    
    q = p1.orientation_histogram(grad[1],grad[0],nbins,np.array([4,4]))
    print(q)

#2.2 Χωρο-χρονικοί Ιστογραφικοί Περιγραφητές
#2.2.1
#var. boxing -> boxing videos
#var. walking -> walking videos
#var. running -> running videos

#golbal var
dh = np.zeros((120,160)) # καθε frame ειναι 120Χ160

x=120
y=160
#paths to save plots
BoxingPath = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/boxingLk/"
WalkingPath = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/walkingLk/"
RunningPath = "/home/thodoris/anaconda3/envs/cv_lab1_env/lab_2/runningLk/"

#save gradients
gradBox = []
gradWalk = []
gradRun = []
#save dx,dy
moveBox = []
moveWalk = []
moveRun = []
for num in range(16): #16 videos
    tempbox = []
    tempwalk = []
    temprun = []
    tempb = []
    tempw = []
    tempr = []
    print("Processing Boxing Videos...")
    video = boxing[num].astype(np.float)/255 # make values in [0,1]
    frame_now = np.zeros((x,y))
    frame_next = np.zeros((x,y))
    
    for z in range (199): #number of frames - 1 
        
        for i in range (x):
            for j in range (y):
                frame_now[i][j]=video[i][j][z]
                frame_next[i][j]=video[i][j][z+1]
        #use polyclimatic lucas kanade
        (dx,dy,grad) = polyclimaticLucas_Kanade_new(frame_now,frame_next,3,0.08,dh,dh,3)
        dx_new=cv2.resize(dx, None, fx=0.5, fy=0.5)
        dy_new=cv2.resize(dy, None, fx=0.5, fy=0.5)
        fig, ax = plt.subplots()
        Q = ax.quiver(-dx_new,-dy_new,angles='xy')
        plt.gca().set_aspect('equal')
        plt.gca().invert_yaxis()
        plt.savefig(BoxingPath + "Video." + str(num) + ".frame." + str(z)+ ".png", bbox_inches='tight')
        tempbox.append(grad)
        tempb.append([dx,dy])
        
    
    print("Processing Walking Videos...")
    video = walking[num].astype(np.float)/255 # make values in [0,1]
    frame_now = np.zeros((x,y))
    frame_next = np.zeros((x,y))
    
    for z in range (199): #number of frames - 1 
        
        for i in range (x):
            for j in range (y):
                frame_now[i][j]=video[i][j][z]
                frame_next[i][j]=video[i][j][z+1]
        #use polyclimatic lucas kanade
        (dx,dy,grad) = polyclimaticLucas_Kanade_new(frame_now,frame_next,3,0.08,dh,dh,3)
        dx_new=cv2.resize(dx, None, fx=0.5, fy=0.5)
        dy_new=cv2.resize(dy, None, fx=0.5, fy=0.5)
        fig, ax = plt.subplots()
        Q = ax.quiver(-dx_new,-dy_new,angles='xy')
        plt.gca().set_aspect('equal')
        plt.gca().invert_yaxis()
        plt.savefig(WalkingPath + "Video." + str(num) + ".frame." + str(z)+ ".png", bbox_inches='tight')
        tempwalk.append(grad)
        tempw.append([dx,dy])
        
        
    print("Processing Running Videos...")
    video = boxing[num].astype(np.float)/255 # make values in [0,1]
    frame_now = np.zeros((x,y))
    frame_next = np.zeros((x,y))
    
    for z in range (199): #number of frames - 1 
        
        for i in range (x):
            for j in range (y):
                frame_now[i][j]=video[i][j][z]
                frame_next[i][j]=video[i][j][z+1]
        #use polyclimatic lucas kanade
        (dx,dy,grad) = polyclimaticLucas_Kanade_new(frame_now,frame_next,3,0.08,dh,dh,3)
        dx_new=cv2.resize(dx, None, fx=0.5, fy=0.5)
        dy_new=cv2.resize(dy, None, fx=0.5, fy=0.5)
        fig, ax = plt.subplots()
        Q = ax.quiver(-dx_new,-dy_new,angles='xy')
        plt.gca().set_aspect('equal')
        plt.gca().invert_yaxis()
        plt.savefig(RunningPath + "Video." + str(num) + ".frame." + str(z) + ".png", bbox_inches='tight')
        temprun.append(grad)
        tempr.append([dx,dy])
        
    print("number of videos processed:", num)

#2.2.2
#var fro 2.2.2
sigma = 4
window_size = 4*sigma 
nbins = 9
#16x16 = 256
#16/4 = 4
n= 4
m = 4

#saving gabor for boxing
gabor = []
counter = 0
for b in boxing:
    print('Num. of video',counter)
    q1 = GaborDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    gabor.append(teliko)
    counter +=1

#saving gabor for walking
gaborW = []
counter = 0
for b in walking:
    print('Num. of video',counter)
    q1 = GaborDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    gaborW.append(teliko)
    counter +=1

#saving gabor for running
gaborR = []
counter = 0
for b in running:
    print('Num. of video',counter)
    q1 = GaborDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    gaborR.append(teliko)
    counter +=1

#saving harris for boxing
harris = []
counter = 0
for b in boxing:
    print('Num. of video',counter)
    q1 = HarrisDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    harris.append(teliko)
    counter +=1

#saving harris for walking
harrisW = []
counter = 0
for b in walking:
    print('Num. of video',counter)
    q1 = HarrisDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    harrisW.append(teliko)
    counter +=1

#saving harris for running
harrisR = []
counter = 0
for b in boxing:
    print('Num. of video',counter)
    q1 = HarrisDetector(b)
    
    gc = np.argsort(q1,axis=None)
    gc1 = np.unravel_index(gc,q1.shape)
    x = gc1[0]
    y = gc1[1]
    t = gc1[2]
    
    x = x[::-1]
    y = y[::-1]
    t = t[::-1]
    teliko = []
    count = 0
    for i,j,z in zip(x,y,t):
        teliko.append([j,i,z,sigma])
        count+=1
        if count == 500:
            break

    teliko = np.array(teliko)
    harrisR.append(teliko)
    counter +=1

#2.2.2 for boxing, gabor
counter = -1
oriantedB = []
for i in gabor:
    counter +=1
    print("Video:",counter)
    flag = False
    boxx = []
    for j in range(199):
        for time in i:
            if time[2] == j:
                #print("Found in frame:",j)
                x = time[0]
                y = time[1]
                (dx,dy,grad) = polyclimaticLucas_Kanade_new(boxing[counter][:,:,j],boxing[counter][:,:,j+1],3,0.08,dh,dh,3)
                if x - 8 <0:
                    if y-8<0:
                        wind = boxing[counter][0:16,0:16,j]
                        gx = grad[1][0:16,0:16]
                        gy = grad[0][0:16,0:16]
                    elif y + 8> 160:
                        wind = boxing[counter][0:16,160-16:160,j]
                        gx = grad[1][0:16,160-16:160]
                        gy = grad[0][0:16,160-16:160]
                    else:
                        wind = boxing[counter][0:16,y-8:y+8,j]
                        gx = grad[1][0:16,y-8:y+8]
                        gy = grad[0][0:16,y-8:y+8]
                elif x + 8 > 120:
                    if y-8<0:
                        wind = boxing[counter][120-16:120,0:16,j]
                        gx = grad[1][120-16:120,0:16]
                        gy = grad[0][120-16:120,0:16]
                    elif y + 8> 160:
                        wind = boxing[counter][120-16:120,160-16:160]
                        gx = grad[1][120-16:120,160-16:160]
                        gy = grad[0][120-16:120,160-16:160]
                    else:
                        wind = boxing[counter][120-16:120,y-8:y+8]
                        gx = grad[1][120-16:120,y-8:y+8]
                        gy = grad[0][120-16:120,y-8:y+8]
                else:
                    if y-8<0:
                        wind = boxing[counter][x-8:x+8,0:16,j]
                        gx = grad[1][x-8:x+8,0:16]
                        gy = grad[0][x-8:x+8,0:16]
                    elif y + 8> 160:
                        wind = boxing[counter][x-8:x+8,160-16:160,j]
                        gx = grad[1][x-8:x+8,160-16:160]
                        gy = grad[0][x-8:x+8,160-16:160]
                    else:
                        wind = boxing[counter][x-8:x+8,y-8:y+8,j]
                        gx = grad[1][x-8:x+8,y-8:y+8]
                        gy = grad[0][x-8:x+8,y-8:y+8]
                
                tmp = p1.orientation_histogram(gx,gy,nbins,np.array([4,4]))
                boxx.append([j,tmp])
                break
    oriantedB.append(boxx)

#2.2.2 for walking, gabor
counter = -1
oriantedW = []
for i in gaborW:
    counter +=1
    print("Video:",counter)
    flag = False
    boxx = []
    for j in range(199):
        for time in i:
            if time[2] == j:
                #print("Found in frame:",j)
                x = time[0]
                y = time[1]
                (dx,dy,grad) = polyclimaticLucas_Kanade_new(waling[counter][:,:,j],walking[counter][:,:,j+1],3,0.08,dh,dh,3)
                if x - 8 <0:
                    if y-8<0:
                        wind = walking[counter][0:16,0:16,j]
                        gx = grad[1][0:16,0:16]
                        gy = grad[0][0:16,0:16]
                    elif y + 8> 160:
                        wind = walking[counter][0:16,160-16:160,j]
                        gx = grad[1][0:16,160-16:160]
                        gy = grad[0][0:16,160-16:160]
                    else:
                        wind = walking[counter][0:16,y-8:y+8,j]
                        gx = grad[1][0:16,y-8:y+8]
                        gy = grad[0][0:16,y-8:y+8]
                elif x + 8 > 120:
                    if y-8<0:
                        wind = walking[counter][120-16:120,0:16,j]
                        gx = grad[1][120-16:120,0:16]
                        gy = grad[0][120-16:120,0:16]
                    elif y + 8> 160:
                        wind = walking[counter][120-16:120,160-16:160]
                        gx = grad[1][120-16:120,160-16:160]
                        gy = grad[0][120-16:120,160-16:160]
                    else:
                        wind = walking[counter][120-16:120,y-8:y+8]
                        gx = grad[1][120-16:120,y-8:y+8]
                        gy = grad[0][120-16:120,y-8:y+8]
                else:
                    if y-8<0:
                        wind = walking[counter][x-8:x+8,0:16,j]
                        gx = grad[1][x-8:x+8,0:16]
                        gy = grad[0][x-8:x+8,0:16]
                    elif y + 8> 160:
                        wind = walking[counter][x-8:x+8,160-16:160,j]
                        gx = grad[1][x-8:x+8,160-16:160]
                        gy = grad[0][x-8:x+8,160-16:160]
                    else:
                        wind = walking[counter][x-8:x+8,y-8:y+8,j]
                        gx = grad[1][x-8:x+8,y-8:y+8]
                        gy = grad[0][x-8:x+8,y-8:y+8]
                
                tmp = p1.orientation_histogram(gx,gy,nbins,np.array([4,4]))
                boxx.append([j,tmp])
                break
    oriantedW.append(boxx)

#2.2.2 for running, gabor
counter = -1
oriantedR = []
for i in gaborR:
    counter +=1
    print("Video:",counter)
    flag = False
    boxx = []
    for j in range(199):
        for time in i:
            if time[2] == j:
                #print("Found in frame:",j)
                x = time[0]
                y = time[1]
                (dx,dy,grad) = polyclimaticLucas_Kanade_new(running[counter][:,:,j],running[counter][:,:,j+1],3,0.08,dh,dh,3)
                if x - 8 <0:
                    if y-8<0:
                        wind = running[counter][0:16,0:16,j]
                        gx = grad[1][0:16,0:16]
                        gy = grad[0][0:16,0:16]
                    elif y + 8> 160:
                        wind = running[counter][0:16,160-16:160,j]
                        gx = grad[1][0:16,160-16:160]
                        gy = grad[0][0:16,160-16:160]
                    else:
                        wind = running[counter][0:16,y-8:y+8,j]
                        gx = grad[1][0:16,y-8:y+8]
                        gy = grad[0][0:16,y-8:y+8]
                elif x + 8 > 120:
                    if y-8<0:
                        wind = running[counter][120-16:120,0:16,j]
                        gx = grad[1][120-16:120,0:16]
                        gy = grad[0][120-16:120,0:16]
                    elif y + 8> 160:
                        wind = running[counter][120-16:120,160-16:160]
                        gx = grad[1][120-16:120,160-16:160]
                        gy = grad[0][120-16:120,160-16:160]
                    else:
                        wind = running[counter][120-16:120,y-8:y+8]
                        gx = grad[1][120-16:120,y-8:y+8]
                        gy = grad[0][120-16:120,y-8:y+8]
                else:
                    if y-8<0:
                        wind = running[counter][x-8:x+8,0:16,j]
                        gx = grad[1][x-8:x+8,0:16]
                        gy = grad[0][x-8:x+8,0:16]
                    elif y + 8> 160:
                        wind = running[counter][x-8:x+8,160-16:160,j]
                        gx = grad[1][x-8:x+8,160-16:160]
                        gy = grad[0][x-8:x+8,160-16:160]
                    else:
                        wind = running[counter][x-8:x+8,y-8:y+8,j]
                        gx = grad[1][x-8:x+8,y-8:y+8]
                        gy = grad[0][x-8:x+8,y-8:y+8]
                
                tmp = p1.orientation_histogram(gx,gy,nbins,np.array([4,4]))
                boxx.append([j,tmp])
                break
    oriantedR.append(boxx)

#2.2.2 for boxing, harris
counter = -1
oriantedHB = []
for i in harris:
    counter +=1
    print("Video:",counter)
    flag = False
    boxx = []
    for j in range(199):
        for time in i:
            if time[2] == j:
                #print("Found in frame:",j)
                x = time[0]
                y = time[1]
                (dx,dy,grad) = polyclimaticLucas_Kanade_new(boxing[counter][:,:,j],boxing[counter][:,:,j+1],3,0.08,dh,dh,3)
                if x - 8 <0:
                    if y-8<0:
                        wind = boxing[counter][0:16,0:16,j]
                        gx = grad[1][0:16,0:16]
                        gy = grad[0][0:16,0:16]
                    elif y + 8> 160:
                        wind = boxing[counter][0:16,160-16:160,j]
                        gx = grad[1][0:16,160-16:160]
                        gy = grad[0][0:16,160-16:160]
                    else:
                        wind = boxing[counter][0:16,y-8:y+8,j]
                        gx = grad[1][0:16,y-8:y+8]
                        gy = grad[0][0:16,y-8:y+8]
                elif x + 8 > 120:
                    if y-8<0:
                        wind = boxing[counter][120-16:120,0:16,j]
                        gx = grad[1][120-16:120,0:16]
                        gy = grad[0][120-16:120,0:16]
                    elif y + 8> 160:
                        wind = boxing[counter][120-16:120,160-16:160]
                        gx = grad[1][120-16:120,160-16:160]
                        gy = grad[0][120-16:120,160-16:160]
                    else:
                        wind = boxing[counter][120-16:120,y-8:y+8]
                        gx = grad[1][120-16:120,y-8:y+8]
                        gy = grad[0][120-16:120,y-8:y+8]
                else:
                    if y-8<0:
                        wind = boxing[counter][x-8:x+8,0:16,j]
                        gx = grad[1][x-8:x+8,0:16]
                        gy = grad[0][x-8:x+8,0:16]
                    elif y + 8> 160:
                        wind = boxing[counter][x-8:x+8,160-16:160,j]
                        gx = grad[1][x-8:x+8,160-16:160]
                        gy = grad[0][x-8:x+8,160-16:160]
                    else:
                        wind = boxing[counter][x-8:x+8,y-8:y+8,j]
                        gx = grad[1][x-8:x+8,y-8:y+8]
                        gy = grad[0][x-8:x+8,y-8:y+8]
                
                tmp = p1.orientation_histogram(gx,gy,nbins,np.array([4,4]))
                boxx.append([j,tmp])
                break
    oriantedHB.append(boxx)

#2.2.2 for walking, harris
counter = -1
oriantedHW = []
for i in harrisW:
    counter +=1
    print("Video:",counter)
    flag = False
    boxx = []
    for j in range(199):
        for time in i:
            if time[2] == j:
                #print("Found in frame:",j)
                x = time[0]
                y = time[1]
                (dx,dy,grad) = polyclimaticLucas_Kanade_new(waling[counter][:,:,j],walking[counter][:,:,j+1],3,0.08,dh,dh,3)
                if x - 8 <0:
                    if y-8<0:
                        wind = walking[counter][0:16,0:16,j]
                        gx = grad[1][0:16,0:16]
                        gy = grad[0][0:16,0:16]
                    elif y + 8> 160:
                        wind = walking[counter][0:16,160-16:160,j]
                        gx = grad[1][0:16,160-16:160]
                        gy = grad[0][0:16,160-16:160]
                    else:
                        wind = walking[counter][0:16,y-8:y+8,j]
                        gx = grad[1][0:16,y-8:y+8]
                        gy = grad[0][0:16,y-8:y+8]
                elif x + 8 > 120:
                    if y-8<0:
                        wind = walking[counter][120-16:120,0:16,j]
                        gx = grad[1][120-16:120,0:16]
                        gy = grad[0][120-16:120,0:16]
                    elif y + 8> 160:
                        wind = walking[counter][120-16:120,160-16:160]
                        gx = grad[1][120-16:120,160-16:160]
                        gy = grad[0][120-16:120,160-16:160]
                    else:
                        wind = walking[counter][120-16:120,y-8:y+8]
                        gx = grad[1][120-16:120,y-8:y+8]
                        gy = grad[0][120-16:120,y-8:y+8]
                else:
                    if y-8<0:
                        wind = walking[counter][x-8:x+8,0:16,j]
                        gx = grad[1][x-8:x+8,0:16]
                        gy = grad[0][x-8:x+8,0:16]
                    elif y + 8> 160:
                        wind = walking[counter][x-8:x+8,160-16:160,j]
                        gx = grad[1][x-8:x+8,160-16:160]
                        gy = grad[0][x-8:x+8,160-16:160]
                    else:
                        wind = walking[counter][x-8:x+8,y-8:y+8,j]
                        gx = grad[1][x-8:x+8,y-8:y+8]
                        gy = grad[0][x-8:x+8,y-8:y+8]
                
                tmp = p1.orientation_histogram(gx,gy,nbins,np.array([4,4]))
                boxx.append([j,tmp])
                break
    oriantedHW.append(boxx)

#2.2.2 for running, harris
counter = -1
oriantedHR = []
for i in harrisR:
    counter +=1
    print("Video:",counter)
    flag = False
    boxx = []
    for j in range(199):
        for time in i:
            if time[2] == j:
                #print("Found in frame:",j)
                x = time[0]
                y = time[1]
                (dx,dy,grad) = polyclimaticLucas_Kanade_new(running[counter][:,:,j],running[counter][:,:,j+1],3,0.08,dh,dh,3)
                if x - 8 <0:
                    if y-8<0:
                        wind = running[counter][0:16,0:16,j]
                        gx = grad[1][0:16,0:16]
                        gy = grad[0][0:16,0:16]
                    elif y + 8> 160:
                        wind = running[counter][0:16,160-16:160,j]
                        gx = grad[1][0:16,160-16:160]
                        gy = grad[0][0:16,160-16:160]
                    else:
                        wind = running[counter][0:16,y-8:y+8,j]
                        gx = grad[1][0:16,y-8:y+8]
                        gy = grad[0][0:16,y-8:y+8]
                elif x + 8 > 120:
                    if y-8<0:
                        wind = running[counter][120-16:120,0:16,j]
                        gx = grad[1][120-16:120,0:16]
                        gy = grad[0][120-16:120,0:16]
                    elif y + 8> 160:
                        wind = running[counter][120-16:120,160-16:160]
                        gx = grad[1][120-16:120,160-16:160]
                        gy = grad[0][120-16:120,160-16:160]
                    else:
                        wind = running[counter][120-16:120,y-8:y+8]
                        gx = grad[1][120-16:120,y-8:y+8]
                        gy = grad[0][120-16:120,y-8:y+8]
                else:
                    if y-8<0:
                        wind = running[counter][x-8:x+8,0:16,j]
                        gx = grad[1][x-8:x+8,0:16]
                        gy = grad[0][x-8:x+8,0:16]
                    elif y + 8> 160:
                        wind = running[counter][x-8:x+8,160-16:160,j]
                        gx = grad[1][x-8:x+8,160-16:160]
                        gy = grad[0][x-8:x+8,160-16:160]
                    else:
                        wind = running[counter][x-8:x+8,y-8:y+8,j]
                        gx = grad[1][x-8:x+8,y-8:y+8]
                        gy = grad[0][x-8:x+8,y-8:y+8]
                
                tmp = p1.orientation_histogram(gx,gy,nbins,np.array([4,4]))
                boxx.append([j,tmp])
                break
    oriantedHR.append(boxx)